# Writers Room Entries API

API endpoints for retrieving Writers Room content entries generated by the n8n multi-LLM workflow.

## Authentication

All endpoints require Bearer token authentication:

```
Authorization: Bearer <your-token>
```

## Base URL

```
/api/writers-room-entries
```

---

## Endpoints

### 1. List Writers Room Entries

Retrieve a paginated list of Writers Room entries with optional filtering and sorting.

**Endpoint:** `GET /api/writers-room-entries`

#### Query Parameters

| Parameter   | Type   | Default      | Description                                                       |
| ----------- | ------ | ------------ | ----------------------------------------------------------------- |
| `page`      | number | 1            | Page number (minimum: 1)                                          |
| `limit`     | number | 50           | Items per page (minimum: 1, maximum: 100)                         |
| `status`    | string | -            | Filter by status: `draft`, `sent`, `published`, `archived`        |
| `brand`     | string | -            | Filter by brand: `tonka_blog`, `tonka_intl`, etc.                 |
| `mode`      | string | -            | Filter by content mode: `blog_post`, `social_post`, `email`, etc. |
| `sortBy`    | string | `created_at` | Sort field: `created_at`, `updated_at`, `status`                  |
| `sortOrder` | string | `desc`       | Sort direction: `asc` or `desc`                                   |

#### Request Example

```http
GET /api/writers-room-entries?page=1&limit=25&status=draft&brand=tonka_blog&sortBy=created_at&sortOrder=desc
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### Success Response (200 OK)

```typescript
{
  content: WritersRoomEntry[];      // Array of entry objects
  count: number;                     // Number of items in current page
  filters: {
    status: string | null;
    brand: string | null;
    mode: string | null;
  };
  pagination: {
    currentPage: number;
    limit: number;
    totalCount: number;              // Total entries matching filters
    totalPages: number;              // Total pages available
  };
  requestId: string;
}
```

#### Error Response (500)

```typescript
{
  code: 'WRITERS_ROOM_ENTRIES_FETCH_FAILED';
  message: 'Failed to retrieve Writers Room entries';
  requestId: string;
}
```

---

### 2. Get Writers Room Entry by ID

Retrieve a single Writers Room entry by its `content_id`.

**Endpoint:** `GET /api/writers-room-entries/:id`

#### Path Parameters

| Parameter | Type   | Required | Description                          |
| --------- | ------ | -------- | ------------------------------------ |
| `id`      | string | Yes      | The `content_id` (UUID) of the entry |

#### Request Example

```http
GET /api/writers-room-entries/637d35f5-f372-4f58-b97e-b7929b7ca7a4
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### Success Response (200 OK)

Returns the full `WritersRoomEntry` object (see Data Types below).

#### Error Responses

**404 Not Found**

```typescript
{
  code: 'NOT_FOUND';
  error: 'Writers Room entry not found: {id}';
}
```

**500 Internal Server Error**

```typescript
{
  code: 'INTERNAL_ERROR';
  error: 'Failed to retrieve Writers Room entry';
}
```

---

## Data Types

### WritersRoomEntry

Complete structure of a Writers Room entry document.

```typescript
interface WritersRoomEntry {
  _id: string; // MongoDB ObjectId
  content_id: string; // UUID - unique content identifier
  status: 'draft' | 'sent' | 'published' | 'archived';
  created_at: string; // ISO 8601 timestamp
  updated_at: string; // ISO 8601 timestamp
  email_sent_at?: string; // ISO 8601 timestamp (optional)

  // Core content
  story_seed: string | null;
  target_audience: string | null;
  target_brand: TargetBrand | null;

  // Project metadata
  project: {
    brand: string; // e.g., "tonka_blog"
    brand_meta: {
      name: string; // e.g., "Tonka Blog"
      slug: string;
      tagline: string;
      voice: string;
      guidelines: {
        do: string[];
        dont: string[];
        style_examples: string[];
      };
    };
    mode: string;
    audience: string;
  } | null;

  project_mode: string | null; // e.g., "blog_post"
  project_mode_profile: {
    label: string;
    description: string;
    headWriterInstructions: string[];
    structureHints: string[];
    taskLines: string[];
  } | null;

  // Final draft content
  final_draft: {
    title: string;
    draft_markdown: string; // Full article content
    summary: string;
    thesis: string;
    role: string; // e.g., "Final Editor"
  } | null;

  title_variations: string[]; // Alternative titles

  // Research data
  research: {
    enable_research: boolean;
    facts: string;
    findings: string[];
    sources: string[];
    citations: string[];
    role: string;
    weight: number;
  } | null;

  // Writer panel configuration
  writer_panel: {
    role: string; // e.g., "comedy", "documentary", "action"
    weight: number;
  }[];

  writers: {
    comedy?: { enabled: boolean; weight: number };
    documentary?: { enabled: boolean; weight: number };
    action?: { enabled: boolean; weight: number };
    biographer?: { enabled: boolean; weight: number };
    historic?: { enabled: boolean; weight: number };
    scifi?: { enabled: boolean; weight: number };
  } | null;

  writer_notes: {
    [role: string]: {
      role: string;
      weight: number;
      notes: string[];
    };
  } | null;

  // Creative settings
  creative: {
    fact_to_fiction: number; // 0-100
    creativity_to_reporter: number; // 0-100
    tone_strictness: number; // 0-100
    length: 'short' | 'medium' | 'long';
  } | null;

  // Platform-specific summaries
  platform_summaries: {
    meta?: string;
    x?: string;
    linkedin?: string;
    tonkaintl?: string;
    youtube?: string;
  } | null;

  // Visual content prompts
  visual_prompts: {
    id: string;
    intent: string; // e.g., "hero", "detail", "process"
    prompt: string;
  }[];

  // Future content suggestions
  future_story_arc_generator: {
    arcs: {
      arc_title: string;
      one_line_premise: string;
      suggested_story_seed: string;
      why_it_matters: string;
    }[];
  } | null;

  // System configuration
  head_writer_system_message: string | null;

  // Outputs
  outputs: {
    gdocs_folder_id?: string; // Google Drive folder ID
    [key: string]: any;
  } | null;

  // Email settings
  notifier_email?: string;
  send_email: boolean;

  // Token usage
  tokens: {
    writer_token_count?: number;
    [key: string]: any;
  } | null;

  __v: number; // Mongoose version key
}

interface TargetBrand {
  id: string;
  project: {
    name: string;
    slug: string;
    tagline: string;
    voice: string;
    guidelines: {
      do: string[];
      dont: string[];
      style_examples: string[];
    };
  };
}
```

---

## Usage Examples

### Frontend: Fetch List with Filters

```typescript
async function fetchWritersRoomEntries(filters: {
  page?: number;
  limit?: number;
  status?: string;
  brand?: string;
  mode?: string;
}) {
  const params = new URLSearchParams();

  if (filters.page) params.append('page', filters.page.toString());
  if (filters.limit) params.append('limit', filters.limit.toString());
  if (filters.status) params.append('status', filters.status);
  if (filters.brand) params.append('brand', filters.brand);
  if (filters.mode) params.append('mode', filters.mode);

  const response = await fetch(
    `/api/writers-room-entries?${params.toString()}`,
    {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    }
  );

  if (!response.ok) {
    throw new Error('Failed to fetch entries');
  }

  return response.json();
}

// Usage
const result = await fetchWritersRoomEntries({
  page: 1,
  limit: 25,
  status: 'draft',
  brand: 'tonka_blog',
});

console.log(`Found ${result.pagination.totalCount} entries`);
console.log(
  `Showing page ${result.pagination.currentPage} of ${result.pagination.totalPages}`
);
```

### Frontend: Fetch Single Entry

```typescript
async function fetchWritersRoomEntry(contentId: string) {
  const response = await fetch(`/api/writers-room-entries/${contentId}`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (response.status === 404) {
    throw new Error('Entry not found');
  }

  if (!response.ok) {
    throw new Error('Failed to fetch entry');
  }

  return response.json();
}

// Usage
const entry = await fetchWritersRoomEntry(
  '637d35f5-f372-4f58-b97e-b7929b7ca7a4'
);

console.log('Title:', entry.final_draft?.title);
console.log('Word count:', entry.final_draft?.draft_markdown?.length);
console.log(
  'Google Docs:',
  entry.outputs?.gdocs_folder_id
    ? `https://drive.google.com/drive/folders/${entry.outputs.gdocs_folder_id}`
    : 'No folder'
);
```

---

## Filter Values Reference

### Valid Status Values

- `draft` - Initial saved state
- `sent` - Email notification sent
- `published` - Content published to platforms
- `archived` - Archived content

### Valid Brand Values

- `tonka_blog`
- `tonka_intl`
- (other brand slugs as defined in constants)

### Valid Mode Values

- `blog_post`
- `social_post`
- `email`
- (other modes as defined in constants)

---

## Notes for Frontend Developers

1. **Authentication**: All requests require a valid Bearer token in the Authorization header. Handle 401 responses by redirecting to login.

2. **Content ID vs MongoDB ID**: Use `content_id` (UUID string) for all API requests, not the MongoDB `_id`.

3. **Pagination**: The list endpoint limits results to 100 items per page maximum. For large datasets, implement pagination controls.

4. **Optional Fields**: Many nested fields can be `null`. Always check for existence before accessing nested properties:

   ```typescript
   const title = entry.final_draft?.title || 'Untitled';
   ```

5. **Google Drive Links**: Construct Google Drive folder URLs from `outputs.gdocs_folder_id`:

   ```typescript
   const driveUrl = entry.outputs?.gdocs_folder_id
     ? `https://drive.google.com/drive/folders/${entry.outputs.gdocs_folder_id}`
     : null;
   ```

6. **Markdown Content**: The `final_draft.draft_markdown` field contains the full article in Markdown format. Use a Markdown parser/renderer for display.

7. **Visual Prompts**: These are AI image generation prompts. The `intent` field categorizes the prompt type (`hero`, `detail`, `process`, `environment`, `metaphor`).

8. **Token Usage**: The `tokens.writer_token_count` tracks LLM token consumption for cost tracking.

9. **Error Handling**: Always check response status codes and handle 404, 500 errors appropriately.

10. **Timestamps**: All timestamps are in ISO 8601 format (`YYYY-MM-DDTHH:mm:ss.sssZ`). Convert to local time for display.
